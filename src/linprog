from z3 import Solver, Real, sat, Sum
from fractions import Fraction

# exact linear programming tools.


# An inequality is generated by a dictionary of pairs {variable, coefficient}, a rhs, and a sense ('leq', 'lt', 'geq', 'gt', 'eq').
class Inequality:
    def __init__(self, coeffs, rhs, sense='leq'):
        # convert coeffs to Fraction for exact arithmetic
        self.coeffs = {v: Fraction(c) for v, c in coeffs.items()} 
        self.rhs = Fraction(rhs)
        assert sense in ['leq', 'lt', 'geq', 'gt', 'eq'], f"Invalid sense: {sense}"
        self.sense = sense

    # return the set of variables in the coeff dictionary
    def variables(self):
        return set(self.coeffs.keys())
        
    def ineq_name(self):
        """
        Return a name for this inequality, suitable for LP solvers.
        """
        return "ineq_"+str(id(self))
            
    def __str__(self):
        """
        Return a string representation of the inequality.
        """
        coeffs_str = ' + '.join(f"{c}*{v}" for v, c in self.coeffs.items())
        match self.sense:
            case 'leq':
                return f"{coeffs_str} <= {self.rhs}"
            case 'lt':
                return f"{coeffs_str} < {self.rhs}"
            case 'geq':
                return f"{coeffs_str} >= {self.rhs}"
            case 'gt':
                return f"{coeffs_str} > {self.rhs}"
            case 'eq':
                return f"{coeffs_str} = {self.rhs}"
            case _:
                raise ValueError(f"Invalid sense: {self.sense}")

        
def ineq_variables(inequalities):
    """
    Return the set of variables in a list of inequalities.
    """
    vars = set()
    for inequality in inequalities:
        vars.update(inequality.variables())
    return vars

def is_infeasible(inequalities):
    """ Test via dual linear programming if a list of inequalities is infeasible """


    # create a z3 variable for each inequality
    dual_vars = {ineq: Real(ineq.ineq_name()) for ineq in inequalities}

    s = Solver()

    # add a non-negativity constraint for each dual variable 
    for ineq in inequalities:
        match ineq.sense:
            case 'leq' | 'lt':
                s.add(dual_vars[ineq] <= 0)
            case 'geq' | 'gt':
                s.add(dual_vars[ineq] >= 0)

    # collect the primal variables
    variables = ineq_variables(inequalities)

    # each primal variable generates a constraint on the dual variables
    for var in variables:
        s.add(Sum(*[dual_vars[ineq] * ineq.coeffs.get(var, 0) for ineq in inequalities]) == 0)

    # sum of the final coefficients must be non-positive
    final_sum = Sum(*[dual_vars[ineq] * ineq.rhs for ineq in inequalities]) 
    
    s.add(final_sum >= 0)

    # also normalize the sum of the final coefficients, plus the gt dual variables, minus the lt dual variables, to 1
    sum_lt_vars = Sum(*[dual_vars[ineq] for ineq in inequalities if ineq.sense == 'lt'])
    sum_gt_vars = Sum(*[dual_vars[ineq] for ineq in inequalities if ineq.sense == 'gt'])
    s.add(final_sum + sum_gt_vars - sum_lt_vars == 1)

    if s.check() == sat:
        print("Infeasible by summing the following:")
        m = s.model()
        for ineq, v in dual_vars.items():
            print(f"{ineq} multiplied by {m[v]}")
        return True
    else:
        print("Feasible")    
        return False 

inequalities = set()
inequalities.add(Inequality({'x1': 1, 'x2': 0}, 3, 'leq'))
inequalities.add(Inequality({'x1': 0, 'x2': 1}, 2, 'leq'))
inequalities.add(Inequality({'x1': 1, 'x2': 1}, 5, 'geq'))
is_infeasible(inequalities)     