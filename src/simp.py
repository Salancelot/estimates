from tactic import *
from sympy import Basic, simplify, Not, Eq
from sympy.core.relational import Relational, Rel

#  The simplifier

def rsimp(goal: Basic, hyp: Basic) -> Basic:
    """
    Recursively simplifies the goal using the hypothesis."""

    new_args = [rsimp(arg, hyp) for arg in goal.args]

    if isinstance(goal, Relational) and isinstance(hyp, Relational):
        if goal.args[0] == hyp.args[0] and goal.args[1] == hyp.args[1]:
            s = 1
        elif goal.args[0] == hyp.args[1] and goal.args[1] == hyp.args[0]:
            s = -1
        else:
            s = 0
        if not s == 0:
            sign = { "<=":{0,1}, "<":{1}, "==":{0}, ">=":{-1,0}, ">":{-1}, "!=":{-1,1}}
            goalset = sign[goal.rel_op]
            hypset = { s * i for i in sign[hyp.rel_op] }
            if hypset.issubset(goalset): # hypothesis implies goal
                return true
            elif hypset.isdisjoint(goalset): # hypothesis contradicts goal
                return false
            else:
                goalset = goalset.intersection(hypset)
                for rel, signset in sign.items(): # hypothesis refines goal
                    if goalset == signset:
                        return Rel(goal.args[0], goal.args[1], rel)
        
    if goal.args == ():
        return goal
    else:
        return goal.func(*new_args) 


def simp(goal: Basic, hyp: Basic) -> Basic:
    """
    Simplifies the goal using the hypothesis.
    """

    # We start with sympy's native simplifier.  WARNING: this symplifier does not completely guard against division by zero (e.g., x/x will simplify to 1 without a proof that x is non-zero), which means that the proofs generated by this tool are not 100% guaranteed to be correct.  In principle this can be fixed by replacing sympy's native simplifier here with a more conservative one that requires guarantees of non-zero denominators (or better yet, outputs a Lean certificate of correctness).

    if isinstance(goal, Type):
        # for now, do not attempt to simplify variable declarations.
        # TODO: if positivity (etc.) has been established as a hypothesis, encode it into the variable.)
        return goal
    
    new_goal =  simplify(goal)
    
    if hyp.is_Boolean:
        # If the hypothesis is a boolean, we can use it to simplify the goal further.
        new_goal = simplify(new_goal.subs(hyp, True))

        if isinstance(hyp, Not):
            new_goal = simplify(new_goal.subs(hyp.args[0], False))
    
    new_goal = rsimp(new_goal, hyp)

    if Eq(new_goal,goal) is not true:
        print(f"Simplified {goal} to {new_goal} using {hyp}.")
    return new_goal


class SimpAll(Tactic):
    """
    Simplifies each hypothesis using other hypotheses, then the goal using the hypothesis.
    """

    def activate(self, state: ProofState) -> list[ProofState]:
        newstate = state.copy()
        for name, hyp in state.hypotheses.items():
            for other_name, other_hyp in newstate.hypotheses.items():
                if other_name != name:  # Cannot use a hypothesis to simplify itself!
                    hyp = simp(hyp, other_hyp)    
            newstate.hypotheses[name] = hyp

        if hyp == true:
            newstate.remove_hypothesis(name)

        if hyp == false:
            print(f"Goal solved by _ex falso quodlibet_.")
            return []
        
        goal = newstate.goal
        for name, hyp in newstate.hypotheses.items():
            goal = simp(goal, hyp)
        newstate.set_goal(goal)

        if goal == true:
            print(f"Goal solved!")
            return []
        else:
            return [newstate]

    def __str__(self):
        return "simp_all"